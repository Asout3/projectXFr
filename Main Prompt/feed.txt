okay here is the importnat files here is the documentation On what chains are the smart contracts going to be deployed?
Ethereum
If you are integrating tokens, are you allowing only whitelisted tokens to work with the codebase or any complying with the standard? Are they assumed to have certain properties, e.g. be non-reentrant? Are there any types ofÂ weird tokensÂ you want to integrate?
There are no third-party tokens being integrated.
Are there any limitations on values set by admins (or other roles) in the codebase, including restrictions on array lengths?
Owner (NOT proxy owner) should generally not be able to do anything that would allow them to steal from the vault.
For example, the LP deposit is only allowed on initialization to avoid scenarios where the owner could manipulate LP liquidity (manip price down, supply a large amount of liquidity at a cheap price, buy tokens cheap) to profit.
They can, of course, "DoS" where they supply all withdrawable funds to staking or LP/Morpho or pause the contract, but the proxy owner should be able to stop any malicious activity there. That is not an exploit.
An example of an exploit we would want to know about is if there were a way owner could supply to Morpho, manipulate prices, and somehow end up profiting. If the owner is able to steal the funds that cannot be recovered by the protocol/proxy, then it may be a valid issue (if it leads to Med/High impact).
Are there any limitations on values set by admins (or other roles) in protocols you integrate with, including restrictions on array lengths?
No
Is the codebase expected to comply with any specific EIPs?
No.
Are there any off-chain mechanisms involved in the protocol (e.g., keeper bots, arbitrage bots, etc.)? We assume these mechanisms will not misbehave, delay, or go offline unless otherwise specified.
There will be staking and unstaking that the multisig owner takes care of. You can assume there will never be a tranche where stakes aren't adjusted or updated.
There will also be a mechanism consistently getting rewards (every 1-2 days).
What properties/invariants do you want to hold even if breaking them has a low/unknown impact?
No
Please discuss any design choices you made.
We currently ignore Morpho rewards in total asset calculation for simplicity's sake. If this can be taken advantage of to result in a loss of funds of it may be a valid finding (if leads to standard requirements for Med/High).
We also decided that withdrawals will expire after 1 day of being finalized in order to avoid users maintaining a finalized withdrawal for immediate exit of the vault if a hack occurs.
We do not drip rewards as we have in past versions. A malicious user could withdraw rewards directly to the contract and bypass the dripping so we decided instead to allow small jumps in price but we will call getRewards more often.
Swap exchange rate is hardcoded for now and will be adjusted upon launch.
Please provide links to previous audits (if any) and all the known issues or acceptable risks.
Previous audits were private but:
Morpho rewards are ignored in total assets.
Dripping rewards is skipped and instead getRewards will be called fairly often.
If tranches aren't reset for a long time (6 months+) they will get lost. Keeper will call more often than that.
There will likely be scenarios where we miss out on some admin fees, such as if fees go uncollected then staked capital is slashed.
We expect all of these to have minor, if any, consequences. If there's a way they can be used to create major consequences that may count as a valid finding. Standard requirements for Medium/High severity apply.
Please list any relevant protocol resources.
stnxm.com has general info on the product. The app page does not currently have real amount data.
GitHub README has more detailed technical info.
Additional audit information.
The context of the update is that all the funds and positions will be migrated from the arNXM to the stNXM.sol.
The context of deployment of stNXM.sol:
Launch contract andÂ initialize
Pause contract
Transfer over NFTs, NXM, and ownership from the old arNXM
Initialize External
Unpause
For the compilation of foundry and hardhat:
INFURA_API_KEY=OWN_API_KEY INFURA_API=https://mainnet.infura.io/v3/OWN_API_KEY MNEMONIC="test test test test test test test test test test test junk" MAINNET_URL_ALCHEMY=https://eth-mainnet.g.alchemy.com/v2/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA TENDERLY_FORK=https://rpc.tenderly.co/fork/BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB MAINNET_INFURA=https://mainnet.infura.io/v3/cccccccccccccccccccccccccccccccc =cccccccccccccccccccccccccccccccc BLOCK_NUMBER=16839410 FORKING=true PRIVATE_KEY1=e916d21c75a564ccb0a51c140c2dec92cb9034202fea65f46ee016828ed0eb63 PRIVATE_KEY2=8b21d3fa24e560354e88e60125b7fe0c2cfb156ed70a092357e361300fc02a56 PRIVATE_KEY3=8b21d3fa24e560354e88e60125b7fe0c2cfb156ed70a092357e361300fc02a56 ETHERSCAN_API_KEY=DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD MAINNET_PRIVATE_KEY=FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF  and here is the other doc ğŸ¦ stNXM Architecture
This document explains howÂ stNXMÂ (Staked NXM) works under the hood: components, flows, accounting, delays, risks, and developer interface.
High-Level Design
Core Components
Asset Accounting
Lifecycle Flows
Withdraw Delay & Pause Logic
Integrations
Admin & Parameters
Events
Developer Interface (Quick Ref)
Security Considerations
Testing Checklist
High-Level Design
stNXM is anÂ ERC4626UpgradeableÂ vault acceptingÂ wNXMÂ and mintingÂ stNXMÂ shares.
Capital is allocated toÂ Nexus MutualÂ staking pools in which it provides underwriting capacity for the mutual's insurance alternatives.
To begin with, small amounts of capital will also be allocated toÂ Uniswap V3Â andÂ Morpho BlueÂ in order to hotstart the LST ecosystem with immediately-available trading, lending, and borrowing.
Rewards from Nexus + Uniswap + Morpho areÂ auto-compoundedÂ into the vault. Withdrawals areÂ delayedÂ and may beÂ pausedÂ during claim events.
Core Components
ModulePurpose (selected functions)ERC4626UpgradeableVault share logic:Â deposit,Â mint,Â withdraw,Â redeem.Nexus stakingTrack pool NFTs & tranches:Â stakeNxm,Â _withdrawFromPool,Â getRewards,Â resetTranches,Â stakedNxm.Uniswap V3LP via position NFTs:Â _mintNewPosition,Â collectDexFees,Â decreaseLiquidity,Â dexBalances.Morpho BlueLend wNXM using Uniswap TWAP oracle:Â morphoDeposit,Â morphoRedeem,Â morphoBalance.Withdrawal controlDelay/queue/pause:Â _withdrawÂ (request),Â withdrawFinalize,Â maxWithdraw,Â maxRedeem,Â togglePause.Fees & adminAdmin fee accrual & payout:Â updateÂ (modifier),Â getRewards,Â withdrawAdminFees,Â changeAdminPercent.
Asset Accounting
Total assetsÂ are the sum of all productive capitalÂ minusÂ admin fees:
totalAssets() = stakedNxm() + unstakedNxm() - adminFees
Where:
stakedNxm()Â = stake acrossÂ all Nexus Mutual pool NFTs & tranchesÂ (handles unexpired & expired tranches).
unstakedNxm()Â = wallet wNXM + wallet NXM +Â Uniswap LP wNXM legÂ +Â MorphoÂ supplied assets (converted sharesâ†’assets).
Admin Fees:Â adminFeesÂ accrue when balance grows (rewards) perÂ adminPercent.
Total supplyÂ excludes â€œvirtual stNXMâ€ minted to the Uniswap pool:
totalSupply() = super.totalSupply() - virtualSharesFromDex
Lifecycle Flows
A. Deposit & Allocation
B. Rewards & Compounding
getRewards():
Iterates all staking NFTs andÂ withdraws rewardsÂ (and expired stake if chosen elsewhere).
CallsÂ collectDexFees()Â to pull Uniswap fees (burns stNXM fee leg; keeps wNXM).
UpdatesÂ adminFeesÂ on newly realized rewards.
Rewards sit asÂ wNXMÂ and are implicitly reflected inÂ totalAssets()Â â†’Â stNXM exchange rate increases.
C. Redemption with Delay
withdraw/redeem:
Initiates a 2 day delay until finalize. Shares are transferred to the contract but not burnt.
stNXM continues to adjust to changes in the underlying assets (if rewards accrue during the delay, they're received).
Ater 2 days, the user has 1 day to finalize otherwise the withdraw fails (to avoid abuse by keeping a withdrawal pending until a hack occurs).
Shares are burnt, assets are sent to the user.
The most important things for safety in redemptions is that a pending withdrawal is affected by slashing (i.e. we cannot decide on value immediately) and that a withdrawal cannot be maintained in a pending state and immediately withdrawn. Both of these are to avoid users looking to abuse the slashing mechanic.
Withdraw Delay & Pause Logic
Delay & queue
_withdraw()Â does notÂ pay immediately. It:
Moves user shares to the vault,
Records a single activeÂ WithdrawalRequestÂ per user,
IncrementsÂ pendingÂ (protects liquidity),
EmitsÂ WithdrawRequested.
withdrawFinalize(user):
EnforcesÂ requestTime + withdrawDelay <= block.timestamp,
One-day finalize window; else shares are returned.
Pause
notPausedÂ modifier blocksÂ _withdrawÂ andÂ withdrawFinalizeÂ whenÂ paused = true.
togglePause()Â isÂ owner-only; intended for admin multisig activation during coverage events.
Integrations
Nexus Mutual (staking)
Stores pool NFTs inÂ tokenIds.
Tracks per-NFTÂ tranche arraysÂ inÂ tokenIdToTranches[tokenId].
Pro-rata stake calc uses poolÂ activeStake,Â stakeSharesSupply, andÂ expired tranche snapshotsÂ when available.
Functions:
stakeNxm(_amount, pool, tranche, requestTokenId)Â (owner),
unstakeNxm(tokenId, trancheIds)Â (anyone; collects expired stake),
getRewards()Â (anyone; pulls rewards),
resetTranches()Â (refreshes tracked tranche windows; 91-day cadence).
Uniswap V3 (LP)
Pair:Â stNXM/wNXM, fee tierÂ 500.
Vault mintsÂ stNXMÂ and pairs withÂ wNXMÂ to create LP positions (NFTs inÂ dexTokenIds).
Fees pulled viaÂ collectDexFees();Â stNXM leg is burned;Â wNXM added to assets.
totalSupply()Â excludes virtual stNXMÂ in LP to keep share accounting accurate.
Morpho Blue (lending)
morphoIdÂ derived from:
assetÂ wNXM, collateralÂ stNXM,Â morphoOracleÂ (Uniswap TWAP),Â irmÂ (interest rate model), and LTV params.
morphoDeposit(_assetAmount)Â supplies wNXM;Â morphoRedeem(_shareAmount)Â withdraws.
morphoBalance()Â converts supplyShares â†’ assets using market totals.
Admin & Parameters
VariableMeaningDefaultwithdrawDelayDelay before a requested withdrawal can be finalized2 dayspausedGlobal pause (affects withdraws/finalize)falseadminPercent10 = 1%Â fee onÂ rewardsÂ (capped at 50% i.e.Â <=500)100Â (10%)beneficiaryRecipient of admin feesset onÂ initialize
Admin functions (owner-only unless noted):
togglePause()
changeWithdrawDelay(uint256)
changeAdminPercent(uint256)Â (requireÂ <=500)
changeBeneficiary(address)
stakeNxm,Â extendDeposit,Â decreaseLiquidity,Â morphoDeposit,Â morphoRedeem
removeTokenIdAtIndex,Â rescueTokenÂ (cannot rescueÂ wNXMÂ orÂ stNXM)
AnyoneÂ can call:Â getRewards(),Â withdrawAdminFees(),Â unstakeNxm()
Events
Deposit(user, asset, share, timestamp)
WithdrawRequested(user, share, asset, requestTime, withdrawTime)
Withdrawal(user, asset, share, timestamp)
NxmReward(reward, timestamp)
Developer Interface (Quick Ref)
User-facing (ERC4626)
deposit(uint256 assets, address receiver) returns (uint256 shares)mint(uint256 shares, address receiver) returns (uint256 assets)withdraw(uint256 assets, address receiver, address owner) returns (uint256 shares) // request-basedredeem(uint256 shares, address receiver, address owner) returns (uint256 assets) // request-basedwithdrawFinalize(address user) // finalize after delaymaxWithdraw(address owner) view returns (uint256) // capped by in-vault wNXM balancemaxRedeem(address owner) view returns (uint256) // capped by in-vault wNXM balance
View/accounting
totalAssets() view returns (uint256)totalSupply() view returns (uint256) // excludes virtual stNXM in LPstakedNxm() view returns (uint256)unstakedNxm() view returns (uint256)dexBalances() view returns (uint256 assets, uint256 shares)morphoBalance() view returns (uint256)trancheAndPoolAllocations() view returns (...) // for frontends
Rewards & fees
getRewards() returns (uint256 rewards) // pulls Nexus rewards + collects LP fees; accrues adminFeescollectDexFees() returns (uint256) // internal use in getRewards()withdrawAdminFees() // pays out accumulated adminFees to beneficiary
Admin/allocation
stakeNxm(uint256 amount, address pool, uint256 tranche, uint256 requestTokenId)extendDeposit(uint256 tokenId, uint256 initialTranche, uint256 newTranche, uint256 topUpAmount)decreaseLiquidity(uint256 tokenId, uint128 liquidity)morphoDeposit(uint256 assetAmount)morphoRedeem(uint256 shareAmount)togglePause()changeWithdrawDelay(uint256)changeAdminPercent(uint256) // <= 500 (50%)changeBeneficiary(address)
Security Considerations
Withdrawal Throttling:Â pendingÂ shares +Â maxWithdraw/maxRedeemÂ ensure users can only exit againstÂ actual wNXM on hand.
Claim Events:Â pausedÂ protects pool funds during claim/slash windows. stNXM can still be sold on dexes which will determine market price.
Admin Fee Bound:Â changeAdminPercentÂ enforcesÂ <= 50%Â cap at contract level.
Virtual Supply:Â Excluding LP-minted stNXM fromÂ totalSupply()Â prevents share price distortion.
Oracle:Â Morpho uses Uniswap TWAP for robust pricing; LP uses fee tier 500 with explicit ticks.
Rescue Guard:Â rescueTokenÂ cannotÂ withdrawÂ wNXM,Â NXM, orÂ stNXM.
Testing Checklist
Â ERC4626 invariants: share/asset conversions, rounding,Â totalAssets()Â monotonicity with rewards.
Â Withdraw delay: request â†’ finalize timelines; missed-window path returns shares.
Â Pause behavior: blocksÂ _withdrawÂ andÂ withdrawFinalize; allowsÂ getRewards.
Â Rewards flow: Nexus rewards collection; Uniswap fee collection (burn stNXM leg); admin fee accrual.
Â LP supply math:Â totalSupply()Â excludes virtual shares;Â dexBalances()Â mirrors NFT positions.
Â Morpho position: supply/redeem round-trips;Â morphoBalance()Â sharesâ†’assets conversion.
Â Tranche roll:Â resetTranches()Â around 91-day boundaries; expired tranche reads.
Â Access control: owner-only functions, rescue guardrails, fee cap.
TL;DRÂ stNXM tokenizes Nexus underwriting into aÂ liquid ERC4626: capital flows to Nexus pools; rewards compound; withdrawals are delayed & pausable to handle claims â€” with robust accounting to keep share price honest.
Hardhat-Foundry Instructions
Getting Started
Use Foundry:
forge install
forge test
Use Hardhat:
npm install
npx hardhat test
Features
Create a .env file with your Infura API
INFURA_API=https://mainnet.infura.io/v3/{YOUR_API_KEY}
Write / run tests with either Hardhat or Foundry or Both:
forge test# or
npx hardhat test# or
npm test (to run both)
Install libraries with Foundry which work with Hardhat.
forge install transmissions11/solmate # Already in this repo, just an example# and
forge remappings > remappings.txt # allows resolve libraries installed with forge or npm i will give you the code and the report next okay here is the code pragma solidity ^0.8.26;
import {ERC4626Upgradeable} from "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC4626Upgradeable.sol";
import {ERC20Upgradeable} from "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol";
import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {Math} from "@openzeppelin/contracts/utils/math/Math.sol";
import {Ownable} from "../general/Ownable.sol";
import {PositionValue} from "../libraries/v3-core/PositionValue.sol";
import {ERC721TokenReceiver} from "../general/ERC721TokenReceiver.sol";
import {INonfungiblePositionManager} from "../interfaces/INonfungiblePositionManager.sol";
import {IUniswapV3Pool} from "../libraries/v3-core/IUniswapV3Pool.sol";
import {IStakingPool, INxmMaster} from "../interfaces/INexusMutual.sol";
import {IMorpho, MarketParams, Position, Market, Id} from "../interfaces/IMorpho.sol";
import {IWNXM} from "../interfaces/IWNXM.sol";
contract StNXM is ERC4626Upgradeable, ERC721TokenReceiver, Ownable {
Â  Â  using SafeERC20 for IERC20;
Â  Â  struct WithdrawalRequest {
Â  Â  Â  Â  uint48 requestTime;
Â  Â  Â  Â  uint104 assets;
Â  Â  Â  Â  uint104 shares;
Â  Â  }
Â  Â  event Deposit(address indexed user, uint256 asset, uint256 share, uint256 timestamp);
Â  Â  event WithdrawRequested(
Â  Â  Â  Â  address indexed user, uint256 share, uint256 asset, uint256 requestTime, uint256 withdrawTime
Â  Â  );
Â  Â  event Withdrawal(address indexed user, uint256 asset, uint256 share, uint256 timestamp);
Â  Â  event NxmReward(uint256 reward, uint256 timestamp);
Â  Â  uint256 private constant DIVISOR = 1000;
Â  Â  IWNXM public constant wNxm = IWNXM(0x0d438F3b5175Bebc262bF23753C1E53d03432bDE);
Â  Â  IERC20 public constant nxm = IERC20(0xd7c49CEE7E9188cCa6AD8FF264C1DA2e69D4Cf3B);
Â  Â  INxmMaster public constant nxmMaster = INxmMaster(0x01BFd82675DBCc7762C84019cA518e701C0cD07e);
Â  Â  IMorpho public constant morpho = IMorpho(0xBBBBBbbBBb9cC5e90e3b3Af64bdAF62C37EEFFCb);
Â  Â  INonfungiblePositionManager public constant nfp =
Â  Â  Â  Â  INonfungiblePositionManager(0xC36442b4a4522E871399CD717aBDD847Ab11FE88);
Â  Â  address public constant irm = 0x870aC11D48B15DB9a138Cf899d20F13F79Ba00BC;
Â  Â  IUniswapV3Pool public dex;
Â  Â  // Needed for morpho MarketParams
Â  Â  address public morphoOracle;
Â  Â  Id public morphoId;
Â  Â  // Delay to withdraw
Â  Â  uint256 public withdrawDelay;
Â  Â  // Total saved amount of withdrawals pending.
Â  Â  uint256 public pending;
Â  Â  // Withdrawals may be paused if a hack has recently happened. Timestamp of when the pause happened.
Â  Â  bool public paused;
Â  Â  // Address that will receive administration funds from the contract.
Â  Â  address public beneficiary;
Â  Â  // Percent of funds to be distributed for administration of the contract. 10 == 1%; 1000 == 100%.
Â  Â  uint256 public adminPercent;
Â  Â  // Amount of fees owed to the admin.
Â  Â  uint256 public adminFees;
Â  Â  // The amount of stake and balance on last update. Needed to make sure a balance change isn't an unstake.
Â  Â  uint256 private lastStaked;
Â  Â  uint256 private lastBalance;
Â  Â  // Whether stNxm is token0 in the dex with wNxm.
Â  Â  bool private isToken0;
Â  Â  // Ids for Uniswap NFTs
Â  Â  uint256[] public dexTokenIds;
Â  Â  /// @dev record of vaults NFT tokenIds
Â  Â  uint256[] public tokenIds;
Â  Â  /// @dev tokenId to risk pool address
Â  Â  mapping(uint256 => address) public tokenIdToPool;
Â  Â  mapping(uint256 => uint256[]) public tokenIdToTranches;
Â  Â  // All withdrawal requests
Â  Â  mapping(address => WithdrawalRequest) public withdrawals;
Â  Â  // ============================================================
Â  Â  //Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  MAIN FUNCTIONS
Â  Â  // ============================================================
Â  Â  /**
Â  Â  Â * @notice Main initializer for the contract.
Â  Â  Â * @param _beneficiary Address that will receive admin fees.
Â  Â  Â * @param _mintAmount The initial amount to mint that will be put into the arNXM/stNXM token swap contract.
Â  Â  Â */
Â  Â  function initialize(address _beneficiary, uint256 _mintAmount) public initializer {
Â  Â  Â  Â  __ERC20_init("Staked NXM", "stNXM");
Â  Â  Â  Â  __ERC4626_init(IERC20(address(wNxm)));
Â  Â  Â  Â  Ownable.initializeOwnable();
Â  Â  Â  Â  // Need to mint a certain amount and send it to owner. This will be similar to arNXM total supply
Â  Â  Â  Â  // since we have a swap contract that will allow people to go from arNXM -> stNXM.
Â  Â  Â  Â  _mint(owner(), _mintAmount);
Â  Â  Â  Â  adminPercent = 100;
Â  Â  Â  Â  beneficiary = _beneficiary;
Â  Â  Â  Â  withdrawDelay = 2 days;
Â  Â  Â  Â  isToken0 = address(this) < address(wNxm);
Â  Â  Â  Â  nxm.approve(address(wNxm), type(uint256).max);
Â  Â  }
Â  Â  /**
Â  Â  Â * @notice Secondary initializer where addresses are set that can't be set in the first yet.
Â  Â  Â * @param _dex The address of the Uni V3 wNXM/stNXM pool.
Â  Â  Â * @param _morphoOracle The stNXM oracle contract that returns twap price from the dex.
Â  Â  Â * @param _dexDeposit The amount of funds to initially deposit into the dex (in wNXM, matched with virtual stNXM).
Â  Â  Â */
Â  Â  function initializeExternals(address _dex, address _morphoOracle, uint256 _dexDeposit) external {
Â  Â  Â  Â  require(msg.sender == owner() && address(dex) == address(0), "Only owner may call, and only call once.");
Â  Â  Â  Â  dex = IUniswapV3Pool(_dex);
Â  Â  Â  Â  morphoOracle = _morphoOracle;
Â  Â  Â  Â  MarketParams memory marketParams =
Â  Â  Â  Â  Â  Â  MarketParams(address(wNxm), address(this), morphoOracle, irm, 625000000000000000);
Â  Â  Â  Â  morphoId = Id.wrap(keccak256(abi.encode(marketParams)));
Â  Â  Â  Â  _mintNewPosition(_dexDeposit, -887270, 887270);
Â  Â  Â  Â  // Initialize with old token IDs
Â  Â  Â  Â  tokenIds.push(214);
Â  Â  Â  Â  tokenIdToPool[214] = 0x5A44002A5CE1c2501759387895A3b4818C3F50b3;
Â  Â  Â  Â  tokenIds.push(215);
Â  Â  Â  Â  tokenIdToPool[215] = 0x5A44002A5CE1c2501759387895A3b4818C3F50b3;
Â  Â  Â  Â  tokenIds.push(242);
Â  Â  Â  Â  tokenIdToPool[242] = 0x34D250E9fA70748C8af41470323B4Ea396f76c16;
Â  Â  Â  Â  // Get the initial tranches
Â  Â  Â  Â  uint256 firstTranche = block.timestamp / 91 days;
Â  Â  Â  Â  for (uint256 i = 0; i < tokenIds.length; i++) {
Â  Â  Â  Â  Â  Â  uint256 id = tokenIds[i];
Â  Â  Â  Â  Â  Â  address _stakingPool = tokenIdToPool[id];
Â  Â  Â  Â  Â  Â  for (uint256 tranche = firstTranche; tranche < firstTranche + 8; tranche++) {
Â  Â  Â  Â  Â  Â  Â  Â  (,, uint256 trancheDeposit,) = IStakingPool(_stakingPool).getDeposit(id, tranche);
Â  Â  Â  Â  Â  Â  Â  Â  if (trancheDeposit > 0) tokenIdToTranches[id].push(tranche);
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  Â  lastBalance = wNxm.balanceOf(address(this));
Â  Â  Â  Â  lastStaked = stakedNxm();
Â  Â  }
Â  Â  /**
Â  Â  Â * @notice Update admin fees based on any changes that occurred between last deposit and withdrawal.
Â  Â  Â * @dev This is to be used on functions that have balance changes unrelated to rewards within them such as deposit/withdraw.
Â  Â  Â */
Â  Â  modifier update() {
Â  Â  Â  Â  // Wrap NXM in case rewards were sent to the contract without us knowing
Â  Â  Â  Â  uint256 nxmBalance = nxm.balanceOf(address(this));
Â  Â  Â  Â  if (nxmBalance > 0) wNxm.wrap(nxmBalance);
Â  Â  Â  Â  uint256 balance = wNxm.balanceOf(address(this));
Â  Â  Â  Â  uint256 staked = stakedNxm();
Â  Â  Â  Â  // This only happens without another update if rewards have entered the contract.
Â  Â  Â  Â  if (balance > lastBalance && lastStaked <= staked) {
Â  Â  Â  Â  Â  Â  adminFees += (balance - lastBalance) * adminPercent / DIVISOR;
Â  Â  Â  Â  }
Â  Â  Â  Â  _;
Â  Â  Â  Â  lastBalance = wNxm.balanceOf(address(this));
Â  Â  Â  Â  lastStaked = stakedNxm();
Â  Â  }
Â  Â  /**
Â  Â  Â * @notice Ensure contract is not currently paused.
Â  Â  Â */
Â  Â  modifier notPaused() {
Â  Â  Â  Â  require(!paused, "Contract is currently paused.");
Â  Â  Â  Â  _;
Â  Â  }
Â  Â  // ============================================================
Â  Â  //Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â PUBLIC FUNCTIONS
Â  Â  // ============================================================
Â  Â  /// We need all of these below to apply the update modifier to them.
Â  Â  function deposit(uint256 assets, address receiver) public override update returns (uint256) {
Â  Â  Â  Â  return super.deposit(assets, receiver);
Â  Â  }
Â  Â  function mint(uint256 shares, address receiver) public override update returns (uint256) {
Â  Â  Â  Â  return super.mint(shares, receiver);
Â  Â  }
Â  Â  function withdraw(uint256 assets, address receiver, address owner) public override update returns (uint256) {
Â  Â  Â  Â  return super.withdraw(assets, receiver, owner);
Â  Â  }
Â  Â  function redeem(uint256 shares, address receiver, address owner) public override update returns (uint256) {
Â  Â  Â  Â  return super.redeem(shares, receiver, owner);
Â  Â  }
Â  Â  /**
Â  Â  Â * @dev Underlying withdraw functions differently from ERC4626 because of the required delay.
Â  Â  Â * @param caller The caller of the function to withdraw.
Â  Â  Â * @param assets The amount of wNXM being withdrawn.
Â  Â  Â * @param shares The amount of stNXM being withdrawn.
Â  Â  Â */
Â  Â  function _withdraw(address caller, address, address, uint256 assets, uint256 shares) internal override notPaused {
Â  Â  Â  Â  require(
Â  Â  Â  Â  Â  Â  _convertToAssets(pending + shares, Math.Rounding.Floor) <= wNxm.balanceOf(address(this)),
Â  Â  Â  Â  Â  Â  "Not enough NXM available for withdrawal."
Â  Â  Â  Â  );
Â  Â  Â  Â  pending += shares;
Â  Â  Â  Â  _transfer(caller, address(this), shares);
Â  Â  Â  Â  WithdrawalRequest memory prevWithdrawal = withdrawals[caller];
Â  Â  Â  Â  // If one withdraw happens before another is finalized, it adds the amounts but resets the request time.
Â  Â  Â  Â  withdrawals[caller] = WithdrawalRequest(
Â  Â  Â  Â  Â  Â  uint48(block.timestamp), prevWithdrawal.assets + uint104(assets), prevWithdrawal.shares + uint104(shares)
Â  Â  Â  Â  );
Â  Â  Â  Â  emit WithdrawRequested(caller, shares, assets, block.timestamp, block.timestamp + withdrawDelay);
Â  Â  }
Â  Â  /// Need to override here so that we can add the update modifier.
Â  Â  function _deposit(address caller, address receiver, uint256 assets, uint256 shares) internal override {
Â  Â  Â  Â  super._deposit(caller, receiver, assets, shares);
Â  Â  }
Â  Â  /**
Â  Â  Â * @notice Finalize a withdraw request after the withdraw delay ends.
Â  Â  Â * @dev Only one withdraw request can be active at a time for a user so this needs no extra params.
Â  Â  Â * @param _user The address to finalize withdrawal for.
Â  Â  Â */
Â  Â  function withdrawFinalize(address _user) external notPaused update {
Â  Â  Â  Â  //address user = msg.sender;
Â  Â  Â  Â  WithdrawalRequest memory withdrawal = withdrawals[_user];
Â  Â  Â  Â  uint256 shares = uint256(withdrawal.shares);
Â  Â  Â  Â  uint256 assets = _convertToAssets(shares, Math.Rounding.Floor);
Â  Â  Â  Â  uint256 requestTime = uint256(withdrawal.requestTime);
Â  Â  Â  Â  require((requestTime + withdrawDelay) <= block.timestamp, "Not ready to withdraw");
Â  Â  Â  Â  require(assets > 0, "No pending amount to withdraw");
Â  Â  Â  Â  pending -= uint256(withdrawal.shares);
Â  Â  Â  Â  delete withdrawals[_user];
Â  Â  Â  Â  // We allow 1 day for the withdraw to be finalized, otherwise it's deleted.
Â  Â  Â  Â  if (block.timestamp > requestTime + withdrawDelay + 1 days) {
Â  Â  Â  Â  Â  Â  _transfer(address(this), _user, shares);
Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  }
Â  Â  Â  Â  _burn(address(this), shares);
Â  Â  Â  Â  wNxm.transfer(_user, assets);
Â  Â  Â  Â  emit Withdrawal(_user, assets, shares, block.timestamp);
Â  Â  }
Â  Â  /**
Â  Â  Â * @notice Collect all rewards from Nexus staking pool and from dex.
Â  Â  Â * @dev These rewards stream to users over the reward duration. Can be called by anyone once the duration is over.
Â  Â  Â */
Â  Â  function getRewards() external update returns (uint256 rewards) {
Â  Â  Â  Â  for (uint256 i = 0; i < tokenIds.length; i++) {
Â  Â  Â  Â  Â  Â  uint256 tokenId = tokenIds[i];
Â  Â  Â  Â  Â  Â  rewards += _withdrawFromPool(tokenIdToPool[tokenId], tokenId, false, true, tokenIdToTranches[tokenId]);
Â  Â  Â  Â  }
Â  Â  Â  Â  // Collect fees from the dex. Compounds back into stNXM value.
Â  Â  Â  Â  rewards += collectDexFees();
Â  Â  Â  Â  // Update for any changes since last interaction
Â  Â  Â  Â  // We don't run the modifier because changes within the function should add to admin fees.
Â  Â  Â  Â  adminFees += rewards * adminPercent / DIVISOR;
Â  Â  Â  Â  emit NxmReward(rewards, block.timestamp);
Â  Â  }
Â  Â  /**
Â  Â  Â * @notice Collect fees from the Uni V3 pool
Â  Â  Â * @dev Does not have update because it's called within getRewards.
Â  Â  Â */
Â  Â  function collectDexFees() public returns (uint256 rewards) {
Â  Â  Â  Â  for (uint256 i = 0; i < dexTokenIds.length; i++) {
Â  Â  Â  Â  Â  Â  // amount0 is wNXM
Â  Â  Â  Â  Â  Â  // amount1 is stNXM
Â  Â  Â  Â  Â  Â  (uint256 amount0, uint256 amount1) = nfp.collect(
Â  Â  Â  Â  Â  Â  Â  Â  INonfungiblePositionManager.CollectParams(
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  dexTokenIds[i],
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  address(this), // recipient of the fees
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  type(uint128).max, // maximum amount of amount0
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  type(uint128).max // maximum amount of amount1
Â  Â  Â  Â  Â  Â  Â  Â  )
Â  Â  Â  Â  Â  Â  );
Â  Â  Â  Â  Â  Â  (uint256 stNxmAmount, uint256 wNxmAmount) = isToken0 ? (amount0, amount1) : (amount1, amount0);
Â  Â  Â  Â  Â  Â  // Burn the stNXM fees.
Â  Â  Â  Â  Â  Â  if (stNxmAmount > 0) _burn(address(this), stNxmAmount);
Â  Â  Â  Â  Â  Â  rewards += wNxmAmount;
Â  Â  Â  Â  }
Â  Â  }
Â  Â  /**
Â  Â  Â * @notice Unstake NXM from pools once the allocation has expired. Can be called by anyone.
Â  Â  Â * @param _tokenId Staking NFT token id.
Â  Â  Â * @param _trancheIds Tranches to unstake from.
Â  Â  Â */
Â  Â  function unstakeNxm(uint256 _tokenId, uint256[] memory _trancheIds) external update {
Â  Â  Â  Â  _withdrawFromPool(tokenIdToPool[_tokenId], _tokenId, true, false, _trancheIds);
Â  Â  }
Â  Â  /**
Â  Â  Â * @notice Check and reset all active tranches for each NFT ID. Can be called by anyone.
Â  Â  Â */
Â  Â  function resetTranches() public update {
Â  Â  Â  Â  // Use the most recently expired tranche
Â  Â  Â  Â  uint256 firstTranche = (block.timestamp / 91 days) - 1;
Â  Â  Â  Â  for (uint256 i = 0; i < tokenIds.length; i++) {
Â  Â  Â  Â  Â  Â  uint256 id = tokenIds[i];
Â  Â  Â  Â  Â  Â  address _stakingPool = tokenIdToPool[id];
Â  Â  Â  Â  Â  Â  delete tokenIdToTranches[id];
Â  Â  Â  Â  Â  Â  for (uint256 tranche = firstTranche; tranche < firstTranche + 9; tranche++) {
Â  Â  Â  Â  Â  Â  Â  Â  (,, uint256 trancheDeposit,) = IStakingPool(_stakingPool).getDeposit(id, tranche);
Â  Â  Â  Â  Â  Â  Â  Â  if (trancheDeposit > 0) tokenIdToTranches[id].push(tranche);
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  }
Â  Â  /**
Â  Â  Â * @notice Withdraw all fees that have accrued to the admin.
Â  Â  Â * @dev Callable by anyone.
Â  Â  Â */
Â  Â  function withdrawAdminFees() external update {
Â  Â  Â  Â  if (adminFees > 0) wNxm.transfer(beneficiary, adminFees);
Â  Â  Â  Â  adminFees = 0;
Â  Â  }
Â  Â  // ============================================================
Â  Â  //Â  Â  Â  Â  Â  Â  Â  Â  Â  OWNER FUNCTIONALITY
Â  Â  // ============================================================
Â  Â  /**
Â  Â  Â * @notice Owner can stake NXM to the desired pool and tranches. Privileged function.
Â  Â  Â * @param _amount Amount of NXM to stake into the pool.
Â  Â  Â * @param _poolAddress Address of the pool that we're staking to.
Â  Â  Â * @param _trancheId ID of the tranche to stake to.
Â  Â  Â * @param _requestTokenId Token ID we're adding to if it's already been minted.
Â  Â  Â */
Â  Â  function stakeNxm(uint256 _amount, address _poolAddress, uint256 _trancheId, uint256 _requestTokenId)
Â  Â  Â  Â  external
Â  Â  Â  Â  onlyOwner
Â  Â  Â  Â  update
Â  Â  {
Â  Â  Â  Â  _stakeNxm(_amount, _poolAddress, _trancheId, _requestTokenId);
Â  Â  }
Â  Â  /**
Â  Â  Â * @notice Extend deposit in a pool we're currently staked in.
Â  Â  Â * @param _tokenId Staking NFT token id.
Â  Â  Â * @param _initialTrancheId Initial tranche id
Â  Â  Â * @param _newTrancheId New tranche id.
Â  Â  Â * @param _topUpAmount Top up amount (0 if we're not adding anything).
Â  Â  Â *
Â  Â  Â */
Â  Â  function extendDeposit(uint256 _tokenId, uint256 _initialTrancheId, uint256 _newTrancheId, uint256 _topUpAmount)
Â  Â  Â  Â  external
Â  Â  Â  Â  onlyOwner
Â  Â  Â  Â  update
Â  Â  {
Â  Â  Â  Â  address stakingPool = tokenIdToPool[_tokenId];
Â  Â  Â  Â  if (_topUpAmount > 0) {
Â  Â  Â  Â  Â  Â  wNxm.unwrap(_topUpAmount);
Â  Â  Â  Â  Â  Â  nxm.approve(nxmMaster.getLatestAddress("TC"), _topUpAmount);
Â  Â  Â  Â  }
Â  Â  Â  Â  IStakingPool(stakingPool).extendDeposit(_tokenId, _initialTrancheId, _newTrancheId, _topUpAmount);
Â  Â  }
Â  Â  /**
Â  Â  Â * @notice Deposit wNXM to Morpho to be lent out with stNXM as collateral.
Â  Â  Â * @param _assetAmount Amount of wNXM to be lent out.
Â  Â  Â */
Â  Â  function morphoDeposit(uint256 _assetAmount) external onlyOwner update {
Â  Â  Â  Â  wNxm.approve(address(morpho), _assetAmount);
Â  Â  Â  Â  morpho.supply(
Â  Â  Â  Â  Â  Â  MarketParams(address(wNxm), address(this), morphoOracle, irm, 625000000000000000),
Â  Â  Â  Â  Â  Â  _assetAmount,
Â  Â  Â  Â  Â  Â  0,
Â  Â  Â  Â  Â  Â  address(this),
Â  Â  Â  Â  Â  Â  ""
Â  Â  Â  Â  );
Â  Â  }
Â  Â  /**
Â  Â  Â * @notice Redeem Morpho assets to get wNXM back into the pool.
Â  Â  Â * @param _shareAmount Amount of Morpho shares to redeem for wNXM.
Â  Â  Â */
Â  Â  function morphoRedeem(uint256 _shareAmount) external onlyOwner update {
Â  Â  Â  Â  morpho.withdraw(
Â  Â  Â  Â  Â  Â  MarketParams(address(wNxm), address(this), morphoOracle, irm, 625000000000000000),
Â  Â  Â  Â  Â  Â  0,
Â  Â  Â  Â  Â  Â  _shareAmount,
Â  Â  Â  Â  Â  Â  address(this),
Â  Â  Â  Â  Â  Â  address(this)
Â  Â  Â  Â  );
Â  Â  }
Â  Â  /**
Â  Â  Â * @notice Decrease liquidity in a token that the vault owns.
Â  Â  Â * @param tokenId ID of the Uni NFT that we're removing from.
Â  Â  Â * @param liquidity Amount of liquidity to remove from the token.
Â  Â  Â */
Â  Â  function decreaseLiquidity(uint256 tokenId, uint128 liquidity) external onlyOwner update {
Â  Â  Â  Â  INonfungiblePositionManager.DecreaseLiquidityParams memory params =
Â  Â  Â  Â  Â  Â  INonfungiblePositionManager.DecreaseLiquidityParams({
Â  Â  Â  Â  Â  Â  Â  Â  tokenId: tokenId, liquidity: liquidity, amount0Min: 0, amount1Min: 0, deadline: block.timestamp
Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  nfp.decreaseLiquidity(params);
Â  Â  Â  Â  (uint256 amount0, uint256 amount1) = nfp.collect(
Â  Â  Â  Â  Â  Â  INonfungiblePositionManager.CollectParams(tokenId, address(this), type(uint128).max, type(uint128).max)
Â  Â  Â  Â  );
Â  Â  Â  Â  uint256 stNxmAmount = isToken0 ? amount0 : amount1;
Â  Â  Â  Â  // Burn stNXM that was removed.
Â  Â  Â  Â  if (stNxmAmount > 0) _burn(address(this), stNxmAmount);
Â  Â  Â  Â  // If we're removing all liquidity, remove from tokenIds.
Â  Â  Â  Â  (,,,,,,, uint128 tokenLiq,,,,) = nfp.positions(tokenId);
Â  Â  Â  Â  if (tokenLiq == 0) {
Â  Â  Â  Â  Â  Â  for (uint256 i = 0; i < dexTokenIds.length; i++) {
Â  Â  Â  Â  Â  Â  Â  Â  if (tokenId == dexTokenIds[i]) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  dexTokenIds[i] = dexTokenIds[dexTokenIds.length - 1];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  dexTokenIds.pop();
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  }
Â  Â  // ============================================================
Â  Â  //Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â VIEW FUNCTIONS
Â  Â  // ============================================================
Â  Â  /**
Â  Â  Â * @notice Get total assets that the vault holds.
Â  Â  Â * @dev This is important to overwrite because it must include wNXM currently being held,
Â  Â  Â *Â  Â  Â  Â NXM currently being staked, wNXM being lent out, wNXM being used as liquidity,
Â  Â  Â *Â  Â  Â  Â and account for tokens currently being withdrawn and rewards being distributed.
Â  Â  Â *Â  Â  Â  Â This also does not always account for exact admin fees, so be wary of that.
Â  Â  Â */
Â  Â  function totalAssets() public view override returns (uint256) {
Â  Â  Â  Â  // Add staked NXM, wNXM in the contract, wNXM in the dex and Morpho, subtract the admin fees.
Â  Â  Â  Â  return stakedNxm() + unstakedNxm() - adminFees;
Â  Â  }
Â  Â  /**
Â  Â  Â * @notice Get the total supply of stNXM.
Â  Â  Â * @dev The stNXM in the dex is "virtual" so it must be removed from total supply.
Â  Â  Â */
Â  Â  function totalSupply() public view override(ERC20Upgradeable, IERC20) returns (uint256) {
Â  Â  Â  Â  // Do not include the "virtual" assets in the Uniswap pool in total supply calculations.
Â  Â  Â  Â  (, uint256 virtualShares) = dexBalances();
Â  Â  Â  Â  return super.totalSupply() - virtualShares;
Â  Â  }
Â  Â  /**
Â  Â  Â * @notice Full amount of NXM that's been staked.
Â  Â  Â */
Â  Â  function stakedNxm() public view returns (uint256 assets) {
Â  Â  Â  Â  for (uint256 i = 0; i < tokenIds.length; i++) {
Â  Â  Â  Â  Â  Â  uint256 token = tokenIds[i];
Â  Â  Â  Â  Â  Â  uint256[] memory trancheIds = tokenIdToTranches[token];
Â  Â  Â  Â  Â  Â  address pool = tokenIdToPool[token];
Â  Â  Â  Â  Â  Â  uint256 activeStake = IStakingPool(pool).getActiveStake();
Â  Â  Â  Â  Â  Â  uint256 stakeSharesSupply = IStakingPool(pool).getStakeSharesSupply();
Â  Â  Â  Â  Â  Â  // Used to determine if we need to check an expired tranche.
Â  Â  Â  Â  Â  Â  uint256 currentTranche = block.timestamp / 91 days;
Â  Â  Â  Â  Â  Â  for (uint256 j = 0; j < trancheIds.length; j++) {
Â  Â  Â  Â  Â  Â  Â  Â  uint256 tranche = trancheIds[j];
Â  Â  Â  Â  Â  Â  Â  Â  (,, uint256 stakeShares,) = IStakingPool(pool).getDeposit(token, tranche);
Â  Â  Â  Â  Â  Â  Â  Â  if (tranche < currentTranche) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  (, uint256 amountAtExpiry, uint256 sharesAtExpiry) = IStakingPool(pool).getExpiredTranche(tranche);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Pool has been properly expired here.
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (sharesAtExpiry > 0) assets += (amountAtExpiry * stakeShares) / sharesAtExpiry;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // The tranche ended but expirations have not been processed.
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  else assets += (activeStake * stakeShares) / stakeSharesSupply;
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  assets += (activeStake * stakeShares) / stakeSharesSupply;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  }
Â  Â  /**
Â  Â  Â * @notice Get all NXM that isn't staked. This includes current balance, lent in Morpho, and liquidity on Uni.
Â  Â  Â */
Â  Â  function unstakedNxm() public view returns (uint256 assets) {
Â  Â  Â  Â  assets = wNxm.balanceOf(address(this));
Â  Â  Â  Â  assets += nxm.balanceOf(address(this));
Â  Â  Â  Â  (uint256 assetsAmount,) = dexBalances();
Â  Â  Â  Â  assets += assetsAmount;
Â  Â  Â  Â  assets += morphoBalance();
Â  Â  }
Â  Â  /**
Â  Â  Â * @notice Find balances of both wNXM and stNXM within the Uniswap pool this contract uses.
Â  Â  Â */
Â  Â  function dexBalances() public view returns (uint256 assetsAmount, uint256 sharesAmount) {
Â  Â  Â  Â  (uint160 sqrtRatio,,,,,,) = dex.slot0();
Â  Â  Â  Â  for (uint256 i = 0; i < dexTokenIds.length; i++) {
Â  Â  Â  Â  Â  Â  (uint256 posAmount0, uint256 posAmount1) = PositionValue.total(nfp, dexTokenIds[i], sqrtRatio);
Â  Â  Â  Â  Â  Â  if (isToken0) {
Â  Â  Â  Â  Â  Â  Â  Â  sharesAmount += posAmount0;
Â  Â  Â  Â  Â  Â  Â  Â  assetsAmount += posAmount1;
Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  sharesAmount += posAmount1;
Â  Â  Â  Â  Â  Â  Â  Â  assetsAmount += posAmount0;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  }
Â  Â  /**
Â  Â  Â * @notice Find the balance (in wNXM) that the vault is lending out on Morpho.
Â  Â  Â */
Â  Â  function morphoBalance() public view returns (uint256 assets) {
Â  Â  Â  Â  Position memory pos = morpho.position(morphoId, address(this));
Â  Â  Â  Â  Market memory market = morpho.market(morphoId);
Â  Â  Â  Â  // Convert shares to assets
Â  Â  Â  Â  assets = (pos.supplyShares * uint256(market.totalSupplyAssets)) / uint256(market.totalSupplyShares);
Â  Â  }
Â  Â  /// stNXM includes the inability to withdraw if the amount is over what's in the contract balance.
Â  Â  function maxWithdraw(address owner) public view override(ERC4626Upgradeable) returns (uint256) {
Â  Â  Â  Â  uint256 ownerMax = _convertToAssets(balanceOf(owner), Math.Rounding.Floor);
Â  Â  Â  Â  uint256 assetBalance = wNxm.balanceOf(address(this));
Â  Â  Â  Â  return assetBalance > ownerMax ? ownerMax : assetBalance;
Â  Â  }
Â  Â  /// stNXM includes the inability to redeem if the amount is over what's in the contract balance.
Â  Â  function maxRedeem(address owner) public view override(ERC4626Upgradeable) returns (uint256) {
Â  Â  Â  Â  uint256 assetBalance = _convertToShares(wNxm.balanceOf(address(this)), Math.Rounding.Floor);
Â  Â  Â  Â  uint256 ownerBalance = balanceOf(owner);
Â  Â  Â  Â  return assetBalance > ownerBalance ? ownerBalance : assetBalance;
Â  Â  }
Â  Â  /// Used by the frontend to see which allocations we have.
Â  Â  /// All we really need to return is amounts from each tranche and separately the amount in each pool
Â  Â  function trancheAndPoolAllocations()
Â  Â  Â  Â  external
Â  Â  Â  Â  view
Â  Â  Â  Â  returns (uint256[] memory pools, uint256[] memory tokenAmounts, uint256[8] memory trancheAmounts)
Â  Â  {
Â  Â  Â  Â  pools = new uint256<a href="tokenIds.length" target="_blank" rel="noopener noreferrer nofollow"></a>;
Â  Â  Â  Â  tokenAmounts = new uint256<a href="tokenIds.length" target="_blank" rel="noopener noreferrer nofollow"></a>;
Â  Â  Â  Â  for (uint256 i = 0; i < tokenIds.length; i++) {
Â  Â  Â  Â  Â  Â  uint256 tokenId = tokenIds[i];
Â  Â  Â  Â  Â  Â  // Pool ID is easier for the frontend since the API uses ID directly
Â  Â  Â  Â  Â  Â  address stakingPool = tokenIdToPool[tokenId];
Â  Â  Â  Â  Â  Â  uint256 poolId = IStakingPool(stakingPool).getPoolId();
Â  Â  Â  Â  Â  Â  uint256 activeStake = IStakingPool(stakingPool).getActiveStake();
Â  Â  Â  Â  Â  Â  uint256 stakeSharesSupply = IStakingPool(stakingPool).getStakeSharesSupply();
Â  Â  Â  Â  Â  Â  pools[i] = poolId;
Â  Â  Â  Â  Â  Â  uint256 currentTranche = block.timestamp / 91 days;
Â  Â  Â  Â  Â  Â  for (uint256 j = 0; j < 8; j++) {
Â  Â  Â  Â  Â  Â  Â  Â  (,, uint256 trancheDeposit,) = IStakingPool(stakingPool).getDeposit(tokenId, currentTranche + j);
Â  Â  Â  Â  Â  Â  Â  Â  uint256 nxmStake = activeStake * trancheDeposit / stakeSharesSupply;
Â  Â  Â  Â  Â  Â  Â  Â  trancheAmounts[j] += nxmStake;
Â  Â  Â  Â  Â  Â  Â  Â  tokenAmounts[i] += nxmStake;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  }
Â  Â  // ============================================================
Â  Â  //Â  Â  Â  Â  Â  Â  Â  Â  Â  Â INTERNAL FUNCTIONS
Â  Â  // ============================================================
Â  Â  /**
Â  Â  Â * @notice Stake any amount of wNXM.
Â  Â  Â * @dev All decisions on pools, amounts, tranches are manual.
Â  Â  Â * @param _amount amount of NXM to stake
Â  Â  Â * @param _poolAddress risk pool address
Â  Â  Â * @param _trancheId tranche to stake NXM in
Â  Â  Â * @param _requestTokenId token id of NFT
Â  Â  Â *
Â  Â  Â */
Â  Â  function _stakeNxm(uint256 _amount, address _poolAddress, uint256 _trancheId, uint256 _requestTokenId) internal {
Â  Â  Â  Â  wNxm.unwrap(_amount);
Â  Â  Â  Â  // Make sure it's the most recent token controller address.
Â  Â  Â  Â  nxm.approve(nxmMaster.getLatestAddress("TC"), _amount);
Â  Â  Â  Â  IStakingPool pool = IStakingPool(_poolAddress);
Â  Â  Â  Â  uint256 tokenId = pool.depositTo(_amount, _trancheId, _requestTokenId, address(this));
Â  Â  Â  Â  tokenIdToTranches[tokenId].push(_trancheId);
Â  Â  Â  Â  // if new nft token is minted we need to keep track of
Â  Â  Â  Â  // tokenId and poolAddress inorder to calculate assets
Â  Â  Â  Â  // under management
Â  Â  Â  Â  if (tokenIdToPool[tokenId] == address(0)) {
Â  Â  Â  Â  Â  Â  tokenIds.push(tokenId);
Â  Â  Â  Â  Â  Â  tokenIdToPool[tokenId] = _poolAddress;
Â  Â  Â  Â  }
Â  Â  }
Â  Â  /**
Â  Â  Â * @notice Withdraw any Nxm we can from the staking pool.
Â  Â  Â * @param _poolAddress Address to withdraw from.
Â  Â  Â * @param _tokenId The token to withdraw rewards from or unstake.
Â  Â  Â * @param _withdrawStake Should we withdraw stake that is past its expiration?
Â  Â  Â * @param _withdrawRewards Should we withdraw rewards gotten from cover being sold?
Â  Â  Â * @param _trancheIds Tranches to withdraw stake and/or rewards from.
Â  Â  Â * @return amount The amount of funds that are being withdrawn.
Â  Â  Â */
Â  Â  function _withdrawFromPool(
Â  Â  Â  Â  address _poolAddress,
Â  Â  Â  Â  uint256 _tokenId,
Â  Â  Â  Â  bool _withdrawStake,
Â  Â  Â  Â  bool _withdrawRewards,
Â  Â  Â  Â  uint256[] memory _trancheIds
Â  Â  ) internal returns (uint256 amount) {
Â  Â  Â  Â  IStakingPool pool = IStakingPool(_poolAddress);
Â  Â  Â  Â  (uint256 withdrawnStake, uint256 withdrawnRewards) =
Â  Â  Â  Â  Â  Â  pool.withdraw(_tokenId, _withdrawStake, _withdrawRewards, _trancheIds);
Â  Â  Â  Â  amount = withdrawnStake + withdrawnRewards;
Â  Â  Â  Â  wNxm.wrap(amount);
Â  Â  }
Â  Â  /**
Â  Â  Â * @notice Used to mint a new Uni V3 position using funds from the stNXM pool. Only used once.
Â  Â  Â * @dev When minting, wNXM is added to the pool from here but stNXM is minted directly to the pool.
Â  Â  Â *Â  Â  Â  Infinite amount of stNXM can be minted, only wNXM held by the contract can be added.
Â  Â  Â * @param amountToAdd wNXM and stNXM amount to add in the new position.
Â  Â  Â * @param _tickLower Low tick of the new position.
Â  Â  Â * @param _tickUpper High tick of the new position.
Â  Â  Â */
Â  Â  function _mintNewPosition(uint256 amountToAdd, int24 _tickLower, int24 _tickUpper) internal {
Â  Â  Â  Â  // 1) sort tokens & map amounts
Â  Â  Â  Â  (address t0, address t1) = isToken0 ? (address(this), address(wNxm)) : (address(wNxm), address(this));
Â  Â  Â  Â  wNxm.approve(address(nfp), amountToAdd);
Â  Â  Â  Â  _mint(address(this), amountToAdd);
Â  Â  Â  Â  _approve(address(this), address(nfp), amountToAdd);
Â  Â  Â  Â  INonfungiblePositionManager.MintParams memory params = INonfungiblePositionManager.MintParams({
Â  Â  Â  Â  Â  Â  token0: t0,
Â  Â  Â  Â  Â  Â  token1: t1,
Â  Â  Â  Â  Â  Â  fee: 500,
Â  Â  Â  Â  Â  Â  tickLower: _tickLower,
Â  Â  Â  Â  Â  Â  tickUpper: _tickUpper,
Â  Â  Â  Â  Â  Â  amount0Desired: amountToAdd,
Â  Â  Â  Â  Â  Â  amount1Desired: amountToAdd,
Â  Â  Â  Â  Â  Â  amount0Min: 0,
Â  Â  Â  Â  Â  Â  amount1Min: 0,
Â  Â  Â  Â  Â  Â  recipient: address(this),
Â  Â  Â  Â  Â  Â  deadline: block.timestamp
Â  Â  Â  Â  });
Â  Â  Â  Â  (uint256 tokenId,, uint256 amount0, uint256 amount1) = nfp.mint(params);
Â  Â  Â  Â  uint256 stNxmAmount = isToken0 ? amount0 : amount1;
Â  Â  Â  Â  // Get rid of any extra stNXM tokens.
Â  Â  Â  Â  if (stNxmAmount < amountToAdd) {
Â  Â  Â  Â  Â  Â  uint256 refund = amountToAdd - stNxmAmount;
Â  Â  Â  Â  Â  Â  _burn(address(this), refund);
Â  Â  Â  Â  }
Â  Â  Â  Â  dexTokenIds.push(tokenId);
Â  Â  }
Â  Â  // ============================================================
Â  Â  //Â  Â  Â  Â  Â  Â  Â  Â  Â ADMINISTRATIVE FUNCTIONS
Â  Â  // ============================================================
Â  Â  /**
Â  Â  Â * @notice Owner can pause the contract at any time. This is used in case a hack occurs and slashing must happen before withdrawals.
Â  Â  Â * @dev Ideally a Nexus-owned multisig has control over the contract so a malicious owner cannot permanently pause.
Â  Â  Â * Make sure pause has breaks in between pauses so a malicious owner cannot keep it paused forever
Â  Â  Â */
Â  Â  function togglePause() external onlyOwner {
Â  Â  Â  Â  paused = !paused;
Â  Â  }
Â  Â  /**
Â  Â  Â * @notice Owner may change the amount of delay required for a withdrawal.
Â  Â  Â * @param _withdrawDelay Withdraw delay.
Â  Â  Â *
Â  Â  Â */
Â  Â  function changeWithdrawDelay(uint256 _withdrawDelay) external onlyOwner {
Â  Â  Â  Â  withdrawDelay = _withdrawDelay;
Â  Â  }
Â  Â  /**
Â  Â  Â * @dev Change the percent of rewards that are given for administration of the contract.
Â  Â  Â * @param _adminPercent The percent of rewards to be given for administration (10 == 1%, 1000 == 100%)
Â  Â  Â *
Â  Â  Â */
Â  Â  function changeAdminPercent(uint256 _adminPercent) external onlyOwner {
Â  Â  Â  Â  require(_adminPercent <= 500, "Cannot give admin more than 50% of rewards.");
Â  Â  Â  Â  adminPercent = _adminPercent;
Â  Â  }
Â  Â  /**
Â  Â  Â * @dev Change beneficiary of the administration funds.
Â  Â  Â * @param _newBeneficiary Address of the new beneficiary to receive funds.
Â  Â  Â */
Â  Â  function changeBeneficiary(address _newBeneficiary) external onlyOwner {
Â  Â  Â  Â  beneficiary = _newBeneficiary;
Â  Â  }
Â  Â  /**
Â  Â  Â * @dev Remove token id from tokenIds array
Â  Â  Â * @param _index Index of the tokenId to remove
Â  Â  Â */
Â  Â  function removeTokenIdAtIndex(uint256 _index) external onlyOwner {
Â  Â  Â  Â  uint256 tokenId = tokenIds[_index];
Â  Â  Â  Â  tokenIds[_index] = tokenIds[tokenIds.length - 1];
Â  Â  Â  Â  tokenIds.pop();
Â  Â  Â  Â  // remove mapping to pool
Â  Â  Â  Â  delete tokenIdToPool[tokenId];
Â  Â  }
Â  Â  /**
Â  Â  Â * @dev Rescue tokens locked in contract
Â  Â  Â * @param token address of token to withdraw
Â  Â  Â */
Â  Â  function rescueToken(address token) external onlyOwner {
Â  Â  Â  Â  require(
Â  Â  Â  Â  Â  Â  token != address(wNxm) && token != address(nxm) && token != address(this),
Â  Â  Â  Â  Â  Â  "Cannot rescue wNXM, NXM or stNXM."
Â  Â  Â  Â  );
Â  Â  Â  Â  uint256 balance = IERC20(token).balanceOf(address(this));
Â  Â  Â  Â  IERC20(token).safeTransfer(msg.sender, balance);
Â  Â  }
}